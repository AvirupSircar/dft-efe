#  Copyright (c) 2021.
#  The Regents of the University of Michigan and DFT-EFE developers.
#
#  This file is part of the DFT-EFE code.
#
#  DFT-EFE is free software: you can redistribute it and/or modify
#    it under the terms of the Lesser GNU General Public License as
#    published by the Free Software Foundation, either version 3 of
#    the License, or (at your option) any later version.
#
#  DFT-EFE is distributed in the hope that it will be useful, but
#    WITHOUT ANY WARRANTY; without even the implied warranty
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
#    See the Lesser GNU General Public License for more details.
#
#  You should have received a copy of the GNU Lesser General Public
#    License at the top level of DFT-EFE distribution.  If not, see
#    <https://www.gnu.org/licenses/>.

import reframe as rfm
import reframe.utility.sanity as sn
from reframe.utility.sanity import evaluate
from reframe.core.backends import getlauncher

# import CompareUtil as cu
parser = rfm.utility.import_module_from_file("../Parser.py")
cu = rfm.utility.import_module_from_file("../CompareUtil.py")
ss = rfm.utility.import_module_from_file("../SetupSystems.py")


@rfm.simple_test
class StdOutTest(rfm.RegressionTest):
    descr = 'Regression Test using CMake and stdout'
    valid_systems = ['*']
    valid_prog_environs = ['*']
    build_system = 'CMake'
    make_opts = ['OperationHost']
    # config_opts = ['''-DDFTEFE_BLAS_LIBRARIES="-L${MKLROOT}/lib/intel64 -Wl,--no-as-needed -lmkl_intel_lp64 -lmkl_gnu_thread -lmkl_core -lgomp -lpthread -lm -ldl"''',
    #                '''-DDFTEFE_SCALAPACK_LIBRARIES="-L${MKLROOT}/lib/intel64 -lmkl_scalapack_lp64 -Wl,--no-as-needed -lmkl_intel_lp64 -lmkl_gnu_thread -lmkl_core -lmkl_blacs_intelmpi_lp64 -lgomp -lpthread -lm -ldl"''',
    #                '''-DCMAKE_PREFIX_PATH="/home/vikramg/DFT-FE-softwares/dealiiDevCustomized/install_gcc8.2.0_openmpi4.0.6_minimal"''',
    #                '''-DENABLE_CUDA=OFF''']
    executable = './OperationHost'
    builddir = './build'
    sourcesdir = './src'
    tagsDict = {'compileOrRun': 'compile', 'unitOrAggregate':
        'aggregate', 'slowOrFast': 'fast', 'arch': 'cpu',
                'serialOrParallel': 'serial'}
    tags = {x for x in tagsDict.values()}
    valid_systems = ss.getValidSystems(tagsDict['arch'])
    valid_prog_environs = ['*']

    # By default ReFrame deletes all the output files generated by the test
    # In case you want to retain any of the files in the output folder of the
    # test, list them in keep_files attribute
    # keep_files = ['out_test1']

    @run_before('compile')
    def set_compiler_flags(self):
        # set the make_opts as defined in the Constructor 
        self.build_system.make_opts = self.make_opts

    @run_before('run')
    def set_launcher_and_resources(self):
        # By default in the config file the launcher for most systems:partitions
        # is set to srun or mpirun. However, for a serial job, we want to set it
        # to the local launcher (i.e., just ./exec)
        if "serial" in self.tags:
            self.job.launcher = getlauncher('local')()

        if "parallel" in self.tags:
            # For jobs launched through srun or mpirun, use the following
            # to set any launcher options
            # Example1: For srun -n 2 ./exec,
            # set the options as self.job.launcher.options = ['-n 2]
            # Example2: For binding cpu to cores
            # self.job.launcher.options = ['--cpu-bind=cores']
            # self.job.launcher.options = ['launcher options to set']
            # By default it is kept blank (as defined below)
            self.job.launcher.options = ['']

        # In order to simplify the resource allocation procedure in a way that
        # is agnostic of the queueing system (Slurm, PBS, Torque, etc.), we use
        # the setResources() function defined in setupSystems.py. The
        # setResources() takes in the following paramters:
        # 1. archTag: string that can be 'cpu', 'gpu', or 'both' (Default: 'both')
        # 2. time_limit: string of the format "hrs:mins:secs"
        #               (Default: "00:02:00")
        # 3. num_nodes: integer for number of nodes to allocate (Default: 1)
        # 4. num_tasks_per_node: integer for number of tasks to use per node
        #                        (Default: 1)
        # 5. mem_per_cpu: string of the format "<number>mb" or "<number>gb" for
        #                 the memory to allocate per cpu (Default: "2gb")
        # 6. gpus_per_node: integer for number of gpus to allocate per node.
        #                  This is used only when the archTag='cpu' or 
        #                   archTag='both'. (Default: 1) 
        # Internally, setResources() function instantiates the 'resources'
        # related placeholders defined in the cofig file. See REFRAME.md
        # for more details
        self.extra_resources = ss.setResources(self.tagsDict['arch'])

    @sanity_function
    def validate_test(self):
        hasTestPassed = True
        msg = 'Passed'
        bmfilename = "OutTestOperationHost.txt"
        bmParser = parser.Parser.fromFilename(bmfilename)
        outParser = parser.Parser.fromFilename(evaluate(self.stdout))
        testSet = ["double add", "double +=", "double -=", "complex<double> add", "complex<double> +=",
                   "complex<double> -="]
        for testString in testSet:
            bmVal = bmParser.extractKeyValues(testString)
            outVal = outParser.extractKeyValues(testString)
            hasTestPassed, norm, msg = cu.Compare().cmp(bmVal, outVal, 1.0e-16, 'absolute', 'point')
            if not hasTestPassed:
                msg = "Failed in {}".format(testString)
                return sn.assert_true(hasTestPassed, msg=msg)
        return sn.assert_true(hasTestPassed, msg=msg)
